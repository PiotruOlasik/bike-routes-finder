import fs from 'fs';
import fetch from 'node-fetch';
import dijkstra from 'dijkstrajs';
import path from 'path';
import { exec } from 'child_process';

import { overpassUrl, query } from './query.js';
import { 
  buildGraphForDijkstra, 
  findNearestNode, 
  areConnected, 
  findConnectedComponents,
  extractRouteMetadata 
} from './utils/graph.js';
import { buildGeoJSONPath, buildDetailedGeoJSON } from './utils/geojson.js';
import { haversineDistance } from './utils/haversine.js';
import { evaluateRoute, bikeTypes } from './utils/bikeRules.js';

/**
 * Zapisuje GeoJSON do GitHub Gist i otwiera w geojson.io
 */
async function openInGeojsonIO(geojsonData) {
  console.log('\nPrzygotowujÄ™ trasÄ™ do wyÅ›wietlenia w geojson.io...');
  
  try {
    // UtwÃ³rz anonimowy Gist
    const gistResponse = await fetch('https://api.github.com/gists', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'BikeRouteApp'
      },
      body: JSON.stringify({
        description: 'Bike route generated by route planner',
        public: true,
        files: {
          'route.geojson': {
            content: JSON.stringify(geojsonData, null, 2)
          }
        }
      })
    });

    if (!gistResponse.ok) {
      throw new Error(`GitHub API error: ${gistResponse.statusText}`);
    }

    const gistData = await gistResponse.json();
    const gistId = gistData.id;
    const rawUrl = gistData.files['route.geojson'].raw_url;
    
    // UtwÃ³rz URL do geojson.io z linkiem do Gist
    const geojsonIOUrl = `https://geojson.io/#id=gist:anonymous/${gistId}`;
    
    console.log('    GeoJSON zapisany jako GitHub Gist');
    console.log(`    Gist ID: ${gistId}`);
    console.log(`    Raw URL: ${rawUrl}`);

    
    // PrÃ³ba otwarcia w przeglÄ…darce
    const command = process.platform === 'win32' ? 'start ""' :
                    process.platform === 'darwin' ? 'open' : 'xdg-open';
    
    exec(`${command} "${geojsonIOUrl}"`, (error) => {
      if (error) {
        console.log('   INSTRUKCJA:');
        console.log('   Ctrl+Click (Windows/Linux) lub Cmd+Click (Mac) na link powyÅ¼ej');
        console.log('   Lub skopiuj link i wklej w przeglÄ…darce\n');
      }
    });

  } catch (error) {
    console.log('   Nie udaÅ‚o siÄ™ uÅ¼yÄ‡ GitHub Gist API');
    console.log(`   â„¹SzczegÃ³Å‚y: ${error.message}`);
    console.log('   Alternatywne rozwiÄ…zanie: ZapisujÄ™ do pliku lokalnego\n');
    
    // Fallback - zapisz lokalnie i pokaÅ¼ instrukcjÄ™
    const outputPath = path.join(process.cwd(), 'route_for_geojson_io.geojson');
    fs.writeFileSync(outputPath, JSON.stringify(geojsonData, null, 2));
    console.log(`   Zapisano do: ${outputPath}`);
    console.log('\n   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('   â•‘    JAK WYÅšWIETLIÄ† TRASÄ˜ W GEOJSON.IO                 â•‘');
    console.log('   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    console.log('   Metoda 1 (zalecana):');
    console.log('   1. OtwÃ³rz \x1b[36mhttps://geojson.io\x1b[0m');
    console.log('   2. PrzeciÄ…gnij plik "route_for_geojson_io.geojson" na mapÄ™');
    console.log('\n   Metoda 2:');
    console.log('   1. OtwÃ³rz \x1b[36mhttps://geojson.io\x1b[0m');
    console.log('   2. Kliknij "Open" â†’ "File"');
    console.log('   3. Wybierz plik "route_for_geojson_io.geojson"\n');
  }
}

async function main() {
  try {

    // KONFIGURACJA 
    const bikeType = 'szosowy'; // Opcje: 'miejski', 'trekkingowy', 'gÃ³rski', 'szosowy'
    const saveToFile = true; // Czy dodatkowo zapisaÄ‡ do pliku
    const openInBrowser = true; // Czy otworzyÄ‡ w geojson.io
    
    // WspÃ³Å‚rzÄ™dne start i meta
    const startLat = 51.46681902975696;
    const startLon = 19.571030370525943;
    const endLat = 51.46722369065393;
    const endLon = 19.601921146542217;

    console.log(`\n${'='.repeat(60)}`);
    console.log(`ğŸš´ PLANOWANIE TRASY ROWEROWEJ`);
    console.log(`${'='.repeat(60)}`);
    console.log(`Typ roweru: ${bikeType}`);
    console.log(`Start: ${startLat}, ${startLon}`);
    console.log(`Meta:  ${endLat}, ${endLon}`);
    console.log(`${'='.repeat(60)}\n`);

    // KROK 1: Pobierz dane z Overpass API
    console.log(' KROK 1: Pobieram dane z Overpass API...');
    const response = await fetch(overpassUrl, {
      method: 'POST',
      body: query,
      headers: { 'Content-Type': 'text/plain' },
    });

    if (!response.ok) {
      throw new Error(`BÅ‚Ä…d pobierania: ${response.statusText}`);
    }

    const osmData = await response.json();
    console.log('    Dane OSM pobrane pomyÅ›lnie');
    console.log(`    ElementÃ³w: ${osmData.elements.length}\n`);

    // KROK 2: Buduj graf z metadanymi
    console.log(' KROK 2: BudujÄ™ graf z metadanymi...');
    const { nodes, graph, wayMetadata } = buildGraphForDijkstra(osmData);
    console.log(`    Graf zbudowany`);
    console.log(`    WÄ™zÅ‚Ã³w: ${nodes.size}`);
    console.log(`    KrawÄ™dzi: ${Object.keys(graph).length}\n`);

    // KROK 3: ZnajdÅº najbliÅ¼sze wÄ™zÅ‚y
    console.log('ğŸ¯ KROK 3: Szukam najbliÅ¼szych wÄ™zÅ‚Ã³w...');
    const startNode = findNearestNode(startLat, startLon, nodes);
    const endNode = findNearestNode(endLat, endLon, nodes);

    if (!startNode || !endNode) {
      console.log('    Nie znaleziono wÄ™zÅ‚Ã³w start/meta.');
      return;
    }

    console.log(`    WÄ™zeÅ‚ startowy: ${startNode}`);
    console.log(`    WÄ™zeÅ‚ koÅ„cowy: ${endNode}\n`);

    // KROK 4: SprawdÅº skÅ‚adowe spÃ³jne
    const startKey = String(startNode);
    const endKey = String(endNode);
    
    console.log(' KROK 4: Analiza skÅ‚adowych spÃ³jnych...');
    const components = findConnectedComponents(graph);
    console.log(`    Graf ma ${components.length} skÅ‚adowych spÃ³jnych`);
    
    let startComponent = -1;
    let endComponent = -1;
    
    for (let i = 0; i < components.length; i++) {
      if (components[i].has(startKey)) startComponent = i;
      if (components[i].has(endKey)) endComponent = i;
    }

    if (startComponent !== endComponent) {
      console.log('\n    WÄ™zÅ‚y sÄ… w rÃ³Å¼nych skÅ‚adowych spÃ³jnych!');
      return;
    }

    console.log('    WÄ™zÅ‚y sÄ… w tej samej skÅ‚adowej spÃ³jnej\n');

    // KROK 5: Oblicz trasÄ™ (Dijkstra)
    console.log('  KROK 5: Obliczam najkrÃ³tszÄ… trasÄ™...');
    const pathNodes = dijkstra.find_path(graph, startKey, endKey);

    if (!pathNodes || pathNodes.length === 0) {
      console.log('    Nie znaleziono trasy.');
      return;
    }

    console.log(`    Znaleziono trasÄ™!`);
    console.log(`    Trasa zawiera ${pathNodes.length} wÄ™zÅ‚Ã³w\n`);

    // KROK 6: Oblicz dÅ‚ugoÅ›Ä‡ trasy
    console.log(' KROK 6: Obliczam dÅ‚ugoÅ›Ä‡ trasy...');
    let totalDistance = 0;
    for (let i = 0; i < pathNodes.length - 1; i++) {
      const a = nodes.get(parseInt(pathNodes[i]));
      const b = nodes.get(parseInt(pathNodes[i + 1]));
      totalDistance += haversineDistance(a.lat, a.lon, b.lat, b.lon);
    }

    console.log(`    DÅ‚ugoÅ›Ä‡ trasy: ${(totalDistance / 1000).toFixed(3)} km\n`);

    // KROK 7: WydobÄ…dÅº metadane trasy
    console.log(' KROK 7: AnalizujÄ™ nawierzchniÄ™...');
    const routeMetadata = extractRouteMetadata(pathNodes, wayMetadata);
    
    const uniqueSurfaces = [...new Set(routeMetadata.surfaces)];
    console.log(`    Nawierzchnie: ${uniqueSurfaces.join(', ')}\n`);

    // KROK 8: OceÅ„ trasÄ™
    console.log('  KROK 8: Oceniam trasÄ™...');
    const evaluation = evaluateRoute(routeMetadata.surfaces, bikeType);
    console.log(`   ${evaluation.message}\n`);

    // KROK 9: Przygotuj GeoJSON
    console.log('ğŸ“¦ KROK 9: PrzygotowujÄ™ GeoJSON...');
    const routeGeoJSON = buildGeoJSONPath(
      pathNodes, 
      nodes, 
      totalDistance, 
      routeMetadata, 
      bikeType, 
      evaluation
    );

    // Opcjonalnie zapisz do pliku
    if (saveToFile) {
      const outputPath = path.join(process.cwd(), 'route_output.geojson');
      fs.writeFileSync(outputPath, JSON.stringify(routeGeoJSON, null, 2));
      console.log('   âœ… Zapisano do route_output.geojson');
    }

    // KROK 10: OtwÃ³rz w geojson.io
    if (openInBrowser) {
      openInGeojsonIO(routeGeoJSON);
    }

    // PODSUMOWANIE
    console.log(`\n${'='.repeat(60)}`);
    console.log(' GOTOWE! Podsumowanie:');
    console.log(`${'='.repeat(60)}`);
    console.log(` Typ roweru:        ${bikeType}`);
    console.log(` DÅ‚ugoÅ›Ä‡ trasy:     ${(totalDistance / 1000).toFixed(3)} km`);
    console.log(` WÄ™zÅ‚Ã³w na trasie:  ${pathNodes.length}`);
    console.log(`  Nawierzchnie:      ${uniqueSurfaces.join(', ')}`);
    console.log(`${evaluation.status === 'success' ? 'âœ…' : evaluation.status === 'warning' ? 'âš ï¸' : 'âŒ'} Status:            ${evaluation.status.toUpperCase()}`);
    console.log(`${'='.repeat(60)}\n`);

  } catch (err) {
    console.error('\n BÅÄ„D:', err.message);
    console.error('Stack trace:', err.stack);
  }
}

main();